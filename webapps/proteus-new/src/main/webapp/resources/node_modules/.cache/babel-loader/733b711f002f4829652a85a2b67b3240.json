{"remainingRequest":"/media/Workings/GSOC-2018/drat/proteus-vue/proteus/node_modules/thread-loader/dist/cjs.js!/media/Workings/GSOC-2018/drat/proteus-vue/proteus/node_modules/babel-loader/lib/index.js!/media/Workings/GSOC-2018/drat/proteus-vue/proteus/node_modules/vue-loader/lib/index.js??vue-loader-options!/media/Workings/GSOC-2018/drat/proteus-vue/proteus/src/components/testii.vue?vue&type=script&lang=js","dependencies":[{"path":"/media/Workings/GSOC-2018/drat/proteus-vue/proteus/src/components/testii.vue","mtime":1530246885112},{"path":"/media/Workings/GSOC-2018/drat/proteus-vue/proteus/node_modules/cache-loader/dist/cjs.js","mtime":1529100185834},{"path":"/media/Workings/GSOC-2018/drat/proteus-vue/proteus/node_modules/thread-loader/dist/cjs.js","mtime":1529100187046},{"path":"/media/Workings/GSOC-2018/drat/proteus-vue/proteus/node_modules/babel-loader/lib/index.js","mtime":1526583314000},{"path":"/media/Workings/GSOC-2018/drat/proteus-vue/proteus/node_modules/vue-loader/lib/index.js","mtime":1527860006000}],"contextDependencies":[],"result":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport * as d3 from 'd3';\nimport TWEEN from 'tween.js';\nvar props = {\n  data: {\n    type: Array,\n    default: function _default() {\n      return [];\n    }\n  },\n  margin: {\n    type: Object,\n    default: function _default() {\n      return {\n        left: 0,\n        right: 0,\n        top: 10,\n        bottom: 10\n      };\n    }\n  },\n  ceil: {\n    type: Number,\n    default: 100\n  }\n};\nexport default {\n  name: 'testii',\n  props: props,\n  mounted: function mounted() {\n    window.addEventListener('resize', this.onResize);\n    this.onResize();\n  },\n  beforeDestry: function beforeDestry() {\n    window.removeEventListener('resize', this.onResize);\n  },\n  watch: {\n    data: function dataChanged(newData, oldData) {\n      this.tweenData(newData, oldData);\n    },\n    width: function widthChanged() {\n      this.initialize();\n      this.update();\n    }\n  },\n  data: function data() {\n    return {\n      width: 0,\n      height: 0,\n      paths: {\n        area: '',\n        line: '',\n        selector: ''\n      },\n      lastHoverPoint: {},\n      scaled: {\n        x: null,\n        y: null\n      },\n      animatedData: [[\"x\", 1]],\n      points: [1, 2, 3, 3]\n    };\n  },\n  methods: {\n    onResize: function onResize() {\n      this.width = this.$el.offsetWidth;\n      this.height = this.$el.offsetHeight;\n    },\n    createArea: d3.area().x(function (d) {\n      return d.x;\n    }).y0(function (d) {\n      return d.max;\n    }).y1(function (d) {\n      return d.y;\n    }),\n    createLine: d3.line().x(function (d) {\n      return d.x;\n    }).y(function (d) {\n      return d.y;\n    }),\n    createValueSelector: d3.area().x(function (d) {\n      return d.x;\n    }).y0(function (d) {\n      return d.max;\n    }).y1(0),\n    initialize: function initialize() {\n      this.scaled.x = d3.scaleLinear().range([0, this.padded.width]);\n      this.scaled.y = d3.scaleLinear().range([this.padded.height, 0]);\n      d3.axisLeft().scale(this.scaled.x);\n      d3.axisBottom().scale(this.scaled.y);\n    },\n    tweenData: function tweenData(newData, oldData) {\n      var vm = this;\n\n      function animate(time) {\n        requestAnimationFrame(animate);\n        TWEEN.update(time);\n      }\n\n      new TWEEN.Tween(oldData).easing(TWEEN.Easing.Quadratic.Out).to(newData, 500).onUpdate(function onUpdate() {\n        vm.animatedData = this;\n        vm.update();\n      }).start();\n      animate();\n    },\n    update: function update() {\n      this.scaled.x.domain(d3.extent(this.data, function (d, i) {\n        return i;\n      }));\n      this.scaled.y.domain([0, this.ceil]);\n      this.points = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.animatedData.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              i = _step$value[0],\n              d = _step$value[1];\n\n          this.points.push({\n            x: this.scaled.x(i),\n            y: this.scaled.y(d),\n            max: this.height\n          });\n          this.$log.info(\"x\");\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.paths.area = this.createArea(this.points);\n      this.paths.line = this.createLine(this.points);\n      this.$log.info(this.points + \"h\");\n    },\n    mouseover: function mouseover(_ref) {\n      var offsetX = _ref.offsetX;\n\n      if (this.points.length > 0) {\n        var x = offsetX - this.margin.left;\n        var closestPoint = this.getClosestPoint(x);\n\n        if (this.lastHoverPoint.index !== closestPoint.index) {\n          var point = this.points[closestPoint.index];\n          this.paths.selector = this.createValueSelector([point]);\n          this.$emit('select', this.data[closestPoint.index]);\n          this.lastHoverPoint = closestPoint;\n        }\n      }\n    },\n    getClosestPoint: function getClosestPoint(x) {\n      return this.points.map(function (point, index) {\n        return {\n          x: point.x,\n          diff: Math.abs(point.x - x),\n          index: index\n        };\n      }).reduce(function (memo, val) {\n        return memo.diff < val.diff ? memo : val;\n      });\n    }\n  },\n  computed: {\n    padded: function padded() {\n      var width = this.width - this.margin.left - this.margin.right;\n      var height = this.height - this.margin.top - this.margin.bottom;\n      return {\n        width: width,\n        height: height\n      };\n    }\n  }\n};",{"version":3,"sources":["testii.vue"],"names":[],"mappings":"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","sourcesContent":["<template lang=\"html\">\n\n  <section class=\"testii\">\n    <div>\n      <svg :width=\"width\" :height=\"height\">\n        <g :style=\"{transform:`translate(${margin.left}px,${margin.top}px`}\">\n          <path class=\"area\" :d=\"paths.area\"/>\n          <path class=\"line\" :d=\"paths.line\"/>\n          <path class=\"selector\" :d=\"paths.selector\"/>\n        </g>\n      </svg>\n    </div>\n  </section>\n\n</template>\n\n<script lang=\"js\">\n  import * as d3 from 'd3';\n  import TWEEN from 'tween.js';\n\n  const props={\n    data:{\n      type:Array,\n      default : ()=>[],\n    },\n    margin:{\n      type:Object,\n      default: ()=>({\n        left:0,\n        right:0,\n        top:10,\n        bottom:10,\n\n      })\n    },\n    ceil:{\n      type:Number,\n      default :100,\n    }\n\n  }\n  export default  {\n    name: 'testii',\n    props,\n    mounted() {\n      window.addEventListener('resize',this.onResize);\n      this.onResize();\n     \n    },\n    beforeDestry(){\n      window.removeEventListener('resize',this.onResize);\n\n    },\n    watch:{\n      data : function dataChanged(newData,oldData) {\n        this.tweenData(newData,oldData);\n      },\n      width: function widthChanged(){\n         \n        this.initialize();\n        this.update();\n      },\n    },\n\n    data() {\n      return {\n          width :0,\n          height:0,\n          paths:{\n            area:'',\n            line:'',\n            selector:'',\n\n          },\n          lastHoverPoint:{},\n          scaled:{\n            x:null,\n            y:null,\n          },\n          animatedData:[[\"x\",1]],\n          points:[1,2,3,3],\n\n\n      }\n    },\n    methods: {\n      onResize(){\n        this.width = this.$el.offsetWidth;\n        this.height = this.$el.offsetHeight;\n      },\n      createArea: d3.area().x(d => d.x).y0(d=>d.max).y1(d=>d.y),\n      createLine: d3.line().x(d=>d.x).y(d=>d.y),\n      createValueSelector:d3.area().x(d=>d.x).y0(d=>d.max).y1(0),\n      initialize(){\n        this.scaled.x = d3.scaleLinear().range([0,this.padded.width]);\n        this.scaled.y = d3.scaleLinear().range([this.padded.height,0]);\n        d3.axisLeft().scale(this.scaled.x);\n        d3.axisBottom().scale(this.scaled.y);\n      },\n      tweenData(newData,oldData){\n        const vm = this;\n        function animate(time){\n          requestAnimationFrame(animate);\n          TWEEN.update(time);\n        }\n        new TWEEN.Tween(oldData)\n        .easing(TWEEN.Easing.Quadratic.Out)\n        .to(newData,500)\n        .onUpdate(function onUpdate(){\n          vm.animatedData = this;\n          vm.update();\n        })\n        .start();\n        animate();\n      },\n\n      update(){\n        this.scaled.x.domain(d3.extent(this.data,(d,i)=>i));\n        this.scaled.y.domain([0,this.ceil]);\n        this.points = [];\n        for(const [i,d] of this.animatedData.entries()){\n          this.points.push({\n            x:this.scaled.x(i),\n            y:this.scaled.y(d),\n            max:this.height,\n          });\n          this.$log.info(\"x\");\n        }\n        this.paths.area = this.createArea(this.points);\n        this.paths.line = this.createLine(this.points);\n        this.$log.info(this.points+\"h\");\n      },\n      mouseover({offsetX}){\n        if(this.points.length>0){\n          const x = offsetX - this.margin.left;\n          const closestPoint = this.getClosestPoint(x);\n          if(this.lastHoverPoint.index !== closestPoint.index){\n            const point = this.points[closestPoint.index];\n            this.paths.selector = this.createValueSelector([point]);\n            this.$emit('select',this.data[closestPoint.index]);\n            this.lastHoverPoint = closestPoint;\n          }\n        }\n      },\n      getClosestPoint(x){\n        return this.points\n        .map((point,index)=>({\n          x:point.x,\n          diff:Math.abs(point.x - x),\n          index,\n        }))\n        .reduce((memo,val) => (memo.diff < val.diff? memo:val));\n      }\n    },\n    computed: {\n        padded(){\n          const width = this.width- this.margin.left -this.margin.right;\n          const height = this.height- this.margin.top - this.margin.bottom;\n\n          return {width,height};\n        },\n    }\n}\n</script>\n\n<style >\n  svg{\n       margin: 25px;\n  \n  }\n  path{\n    fill: none;\n    stroke: #76BF8A;\n    stroke-width: 3px;\n  }\n\n  area{\n    fill: #76BF8A;\n  }\n  line{\n  stroke: #4F7F5C;\n  stroke-width: 1px;\n  fill: none\n  }\n  selector{\n    stroke: #28402E;\n    stroke-width: 3px;\n    fill: none\n  }\n</style>\n"],"sourceRoot":"src/components"}]}